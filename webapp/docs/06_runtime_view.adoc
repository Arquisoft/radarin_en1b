[[section-runtime-view]]
== Runtime View


[role="arc42help"]
****
.Contents
The runtime view describes concrete behavior and interactions of the systemâ€™s building blocks in form of scenarios from the following areas:

* important use cases or features: how do building blocks execute them?
* interactions at critical external interfaces: how do building blocks cooperate with users and neighboring systems?
* operation and administration: launch, start-up, stop
* error and exception scenarios

Remark: The main criterion for the choice of possible scenarios (sequences, workflows) is their *architectural relevance*. It is *not* important to describe a large number of scenarios. You should rather document a representative selection.

.Motivation
You should understand how (instances of) building blocks of your system perform their job and communicate at runtime.
You will mainly capture scenarios in your documentation to communicate your architecture to stakeholders that are less willing or able to read and understand the static models (building block view, deployment view).

.Form
There are many notations for describing scenarios, e.g.

* numbered list of steps (in natural language)
* activity diagrams or flow charts
* sequence diagrams
* BPMN or EPCs (event process chains)
* state machines
* ...

****
This section will be in contrast with the last, as we will cover here the dynamic behaviour and how users interact between them.

=== Alice wants to know if his friends are near her.


* _Today, Alice is bored at home, but she wants to do something, taking into account COVID-19 restrictions.
    As a consequence of these restrictions, she cannot leave her town, and wants to know if some of his friends are near her._
* _As you can see in the diagram below, at first Alice has to authenticate and allow sharing his location in order to find his mutuals between a proximity radius.
    Once this is done, his App (the instance of our App downloaded in her mobile) asks Alice's Pod for the list of her friends, to be shown to Alice in the radar just in case they are near her.
    Then, Alice's last location is shared to the server where it is going to be stored, and it is a minimum piece of information, as the majority of the data will be in every user's Pod.
    After this, Alice's Pod returns to Alice's App the information needed of his friends, and the App itself computes the distance to her online friends, and discard those that are offline.
    Finally, Alice receives the radar, with only those friends that are online._

[plantuml,"Sequence diagram 1",png]
----
actor Alice
entity MAApp as "Alice's Mobile App"
database Pod1 as "Alice's Pod"
database Server as "Web Server"
Alice --> MAApp: Authenticates and allows to share her location
MAApp --> Pod1: Accesses the list of friends
MAApp --> Server: Sends the last location
MAApp <-- Pod1: Retrieves the information needed
MAApp <-- MAApp: Computes and manages distances to show in radar
Alice <-- MAApp: The radar is shown
----
=== Alice wants to know if his friends are near her, but she doesn't have Internet Connection.
* _In this case, we have the same exact context as in the previous use case, but this time, Alice went for a walk with her dog to the mountain, and at a certain point of the walk, she lost the connection to the Internet._
* _It is the same context. Alice was already authenticated, and allowed to share her location, but with after some time, the server has not received any recent location (more recent than a given amount of time), and, as a consequence, she is not able to see the radar._

[plantuml,"Sequence diagram 2",png]
----
actor Alice
entity MAApp as "Alice's Mobile App"
database Pod1 as "Alice's Pod"
database Server as "Web Server"
Alice --> MAApp: Authenticates and allows to share her location
MAApp --> Pod1: Accesses the list of friends
MAApp --> Server: Is not able to send the location
MAApp <-- Pod1: No new information is retrieved
MAApp <-- MAApp: It is not able to compute what is needed
Alice <-- MAApp: An alert is shown
----


