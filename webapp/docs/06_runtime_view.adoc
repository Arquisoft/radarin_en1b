[[section-runtime-view]]
== Runtime View


[role="arc42help"]
****
.Contents
The runtime view describes concrete behavior and interactions of the systemâ€™s building blocks in form of scenarios from the following areas:

* important use cases or features: how do building blocks execute them?
* interactions at critical external interfaces: how do building blocks cooperate with users and neighboring systems?
* operation and administration: launch, start-up, stop
* error and exception scenarios

Remark: The main criterion for the choice of possible scenarios (sequences, workflows) is their *architectural relevance*. It is *not* important to describe a large number of scenarios. You should rather document a representative selection.

.Motivation
You should understand how (instances of) building blocks of your system perform their job and communicate at runtime.
You will mainly capture scenarios in your documentation to communicate your architecture to stakeholders that are less willing or able to read and understand the static models (building block view, deployment view).

.Form
There are many notations for describing scenarios, e.g.

* numbered list of steps (in natural language)
* activity diagrams or flow charts
* sequence diagrams
* BPMN or EPCs (event process chains)
* state machines
* ...

****
This section will have a contrast with the last, as we will cover here the dynamic behaviour and how users interact between them.

=== Alice wants to know if Bob is near here, and Bob allows Alice to see him in the radar


* _Today, Alice is bored at home, but she wants to do something, taking into account COVID-19 restrictions.
    As a consequence of these restrictions, she cannot leave her town, and wants to know if his best friend Bob
    who lives in the same town as her, is near. As Bob allows Alice to find her in the application, Alice is able to access Bob's location in case he is near her._
* _As you can see in the diagram below, at first Alice has to authenticate and allow sharing his location in order to find his mutuals between a proximity radius.
    Then, her pod shares the location with the App, that will compute the distance to the mutuals that have previously allowed the App to do so. In this case, Alice wants to see in the radar Bob's location, that hasn't previously allowed the App to share the location.
    As a consequence, the App sends a request to Bob's pod, and the pod, to Bob respectively.
    Once Bob accepts wether he wants to share his location (or not, in this case, he wants to),
    the response is sent to the pod, and from the pod is sent to the App, that manages Alice's and Bob's locations,and if they are near enough (in this case, they are), Bob appears in Alice's radar._

[plantuml,"Sequence diagram 1",png]
----
actor Alice
database Pod1 as "Alice's Pod"
database App as "Main App"
database Pod2 as "Bob's Pod"
actor Bob
Alice --> Pod1: Authenticates and allows to share her location
Pod1 --> App: Share's Alice location with the app
App  -> Pod2: Asks for Bob's permission to share his location
Pod2 -> Bob: Sends a petition
Pod2 <-- Bob: Accepts to share his location
App <-- Pod2: Sends the response
Pod1 <-- App: Manages the response, and shows Bob in the radar
Alice <-- Pod1: Radar with Bob's location
----
=== Alice wants to know if Bob is near here, and Bob doesn't want Alice to see him in the radar
* _For this case, we have the same exact context as in the previous use case, but this time, Bob is at home
    watching some sitcoms, and is not allowing nothing to disturb him, so it refuses to connect with Alice in the App_
* _As you can see in the diagram below, at first Alice has to authenticate and allow sharing his location in order to find his mutuals between a proximity radius.
    Then, her pod shares the location with the App, that will compute the distance to the mutuals that have previously allowed the App to do so. In this case, Alice wants to see in the radar Bob's location, that hasn't previously allowed the App to share the location.
    As a consequence, the App sends a request to Bob's pod, and the pod, to Bob respectively.
    The difference, is that this time, Bob refuses the petition, as he doesn't want to leave the sofa today.
    As a consequence, the response to the petition it is sent to the pod, and from the pod to the App,
    that will manage Bob's response, not showing him in the radar, but Alice will not know that it was because
    Bob refused the connection._

[plantuml,"Sequence diagram 2",png]
----
actor Alice
database Pod1 as "Alice's Pod"
database App as "Main App"
database Pod2 as "Bob's Pod"
actor Bob
Alice --> Pod1: Authenticates and allows to share her location
Pod1 --> App: Share's Alice location with the app
App  -> Pod2: Asks for Bob's permission to share his location
Pod2 -> Bob: Sends a petition
Pod2 <-- Bob: Refuses the petition
App <-- Pod2: Sends the response
Pod1 <-- App: Manages the response, and doesn't show Bob in the radar
Alice <-- Pod1: Radar without Bob's location
----

=== Alice wants to know if Bob is near here, and Bob allows Alice to see him in the radar, but they are not near enough
* _Now, Bob has changed his mind, and is bored from laying on the coach, and wants to share his location with Alice, just in case she is online allowing them to meet. But Alice, breaking COVID-19 restrictions by the gobernment, has gone to take a walk with her dog, and without realizing, she left the town.
However, she remains online in the app, but it is not able to see Bob there._
* _As you can see in the diagram below, at first Alice has to authenticate and allow sharing his location in order to find his mutuals between a proximity radius.
    Then, her pod shares the location with the App, that will compute the distance to the mutuals that have previously allowed the App to do so. In this case, Alice wants to see in the radar Bob's location, that hasn't previously allowed the App to share the location.
    As a consequence, the App sends a request to Bob's pod, and the pod, to Bob respectively.
    Bob is bored, so he accepts the petition, and then the response is sent to the pod, and then to the App
    But this time, the App is trying to match both Alice and Bob locations, but they escape from the proximity range established, so it has to manage this not showing Bob in Alice's radar._

[plantuml,"Sequence diagram 3",png]
----
actor Alice
database Pod1 as "Alice's Pod"
database App as "Main App"
database Pod2 as "Bob's Pod"
actor Bob
Alice --> Pod1: Authenticates and allows to share her location
Pod1 --> App: Share's Alice location with the app
App  -> Pod2: Asks for Bob's permission to share his location
Pod2 -> Bob: Sends a petition
Pod2 <-- Bob: Accepts the petition
App <-- Pod2: Sends the response
Pod1 <-- App: Manages the response, but they are far, so Bob is not showing in the radar
Alice <-- Pod1: Radar without Bob's location
----

